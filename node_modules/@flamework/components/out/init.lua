-- Compiled with roblox-ts v2.0.2
local TS = _G[script]
local Maid = TS.import(script, TS.getModule(script, "@rbxts", "maid").Maid)
local _services = TS.import(script, TS.getModule(script, "@rbxts", "services"))
local CollectionService = _services.CollectionService
local RunService = _services.RunService
local _core = TS.import(script, TS.getModule(script, "@flamework", "core").out)
local Service = _core.Service
local Controller = _core.Controller
local Flamework = _core.Flamework
local Reflect = _core.Reflect
local Modding = _core.Modding
local Signal = TS.import(script, TS.getModule(script, "@rbxts", "signal"))
--[[
	*
	* Register a class as a Component.
	*
	* @metadata flamework:implements flamework:parameters
]]
local Component = Modding.createMetaDecorator("Class")
local BaseComponent
do
	BaseComponent = setmetatable({}, {
		__tostring = function()
			return "BaseComponent"
		end,
	})
	BaseComponent.__index = BaseComponent
	function BaseComponent.new(...)
		local self = setmetatable({}, BaseComponent)
		return self:constructor(...) or self
	end
	function BaseComponent:constructor()
		self.maid = Maid.new()
		self._attributeChangeHandlers = {}
	end
	function BaseComponent:setInstance(instance, attributes)
		self.instance = instance
		self.attributes = attributes
	end
	function BaseComponent:setAttribute(key, value, postfix)
		local previousValue = self.attributes[key]
		self.attributes[key] = value
		self.instance:SetAttribute(key, value)
		return if postfix then previousValue else value
	end
	function BaseComponent:onAttributeChanged(name, cb)
		local __attributeChangeHandlers = self._attributeChangeHandlers
		local _name = name
		local list = __attributeChangeHandlers[_name]
		if not list then
			local __attributeChangeHandlers_1 = self._attributeChangeHandlers
			local _exp = name
			list = Signal.new()
			local _list = list
			__attributeChangeHandlers_1[_exp] = _list
		end
		return list:Connect(cb)
	end
	function BaseComponent:destroy()
		self.maid:Destroy()
	end
end
--[[
	*
	* This class is responsible for loading and managing
	* all components in the game.
]]
local Components
do
	Components = setmetatable({}, {
		__tostring = function()
			return "Components"
		end,
	})
	Components.__index = Components
	function Components.new(...)
		local self = setmetatable({}, Components)
		return self:constructor(...) or self
	end
	function Components:constructor()
		self.components = {}
		self.classParentCache = {}
		self.activeComponents = {}
		self.activeInheritedComponents = {}
		self.reverseComponentsMapping = {}
	end
	function Components:onInit()
		local components = {}
		local componentConstructors = Modding.getDecorators("$c:init@Component")
		for _, _binding in componentConstructors do
			local ctor = _binding.object
			local args = _binding.arguments
			local identifier = Reflect.getMetadata(ctor, "identifier")
			local _arg1 = {
				ctor = ctor,
				config = args[1] or {},
				identifier = identifier,
			}
			components[ctor] = _arg1
		end
		self.components = components
	end
	function Components:onStart()
		for _, _binding in self.components do
			local config = _binding.config
			local ctor = _binding.ctor
			local identifier = _binding.identifier
			if config.tag ~= nil then
				local instanceGuard = self:getConfigValue(ctor, "instanceGuard")
				local predicate = self:getConfigValue(ctor, "predicate")
				local addConnections = {}
				local removeConnections = {}
				local setupRemovedConnection
				local setupAddedConnection = function(instance)
					local connection
					connection = instance.DescendantAdded:Connect(function()
						if instanceGuard(instance) then
							self:addComponent(instance, ctor, true)
							connection:Disconnect()
							local _instance = instance
							addConnections[_instance] = nil
							setupRemovedConnection(instance)
						end
					end)
					local _instance = instance
					addConnections[_instance] = connection
				end
				setupRemovedConnection = function(instance)
					local connection
					connection = instance.DescendantRemoving:Connect(function()
						-- The parent does not change until the next frame, so the guard will
						-- always succeed unless we yield.
						RunService.Heartbeat:Wait()
						if not instanceGuard(instance) then
							self:removeComponent(instance, ctor)
							connection:Disconnect()
							local _instance = instance
							removeConnections[_instance] = nil
							setupAddedConnection(instance)
						end
					end)
					local _instance = instance
					removeConnections[_instance] = connection
				end
				local instanceAdded = function(instance)
					if predicate ~= nil and not predicate(instance) then
						return nil
					end
					if RunService:IsServer() or not instanceGuard then
						return self:addComponent(instance, ctor)
					end
					if instanceGuard(instance) then
						self:addComponent(instance, ctor, true)
						setupRemovedConnection(instance)
					else
						setupAddedConnection(instance)
					end
				end
				CollectionService:GetInstanceAddedSignal(config.tag):Connect(instanceAdded)
				CollectionService:GetInstanceRemovedSignal(config.tag):Connect(function(instance)
					local _instance = instance
					local addConnection = addConnections[_instance]
					local _instance_1 = instance
					local removeConnection = removeConnections[_instance_1]
					local _instance_2 = instance
					addConnections[_instance_2] = nil
					local _instance_3 = instance
					removeConnections[_instance_3] = nil
					local _result = addConnection
					if _result ~= nil then
						_result:Disconnect()
					end
					local _result_1 = removeConnection
					if _result_1 ~= nil then
						_result_1:Disconnect()
					end
					self:removeComponent(instance, ctor)
				end)
				for _1, instance in CollectionService:GetTagged(config.tag) do
					self:safeCall("Failed to instantiate '" .. (identifier .. ("' for " .. tostring(instance))), function()
						return instanceAdded(instance)
					end)
				end
			end
		end
	end
	function Components:getParentConstructor(ctor)
		local metatable = getmetatable(ctor)
		if metatable and type(metatable) == "table" then
			local parentConstructor = rawget(metatable, "__index")
			return parentConstructor
		end
	end
	function Components:getOrderedParents(ctor, omitBaseComponent)
		if omitBaseComponent == nil then
			omitBaseComponent = true
		end
		local _classParentCache = self.classParentCache
		local _ctor = ctor
		local cache = _classParentCache[_ctor]
		if cache then
			return cache
		end
		local classes = { ctor }
		local nextParent = ctor
		while true do
			nextParent = self:getParentConstructor(nextParent)
			if not (nextParent ~= nil) then
				break
			end
			if not omitBaseComponent or nextParent ~= BaseComponent then
				local _nextParent = nextParent
				table.insert(classes, _nextParent)
			end
		end
		local _classParentCache_1 = self.classParentCache
		local _ctor_1 = ctor
		_classParentCache_1[_ctor_1] = classes
		return classes
	end
	function Components:getAttributeGuards(ctor)
		local attributes = {}
		local _components = self.components
		local _ctor = ctor
		local metadata = _components[_ctor]
		if metadata then
			if metadata.config.attributes ~= nil then
				for attribute, guard in pairs(metadata.config.attributes) do
					attributes[attribute] = guard
				end
			end
			local parentCtor = getmetatable(ctor)
			if parentCtor.__index ~= nil then
				for attribute, guard in self:getAttributeGuards(parentCtor.__index) do
					if not (attributes[attribute] ~= nil) then
						attributes[attribute] = guard
					end
				end
			end
		end
		return attributes
	end
	function Components:getAttributes(instance, componentInfo, guards)
		local attributes = instance:GetAttributes()
		local newAttributes = {}
		local defaults = componentInfo.config.defaults
		for key, guard in pairs(guards) do
			local attribute = attributes[key]
			if not guard(attribute) then
				local _result = defaults
				if _result ~= nil then
					_result = _result[key]
				end
				if _result ~= nil then
					local _arg1 = defaults[key]
					newAttributes[key] = _arg1
					instance:SetAttribute(key, defaults[key])
				else
					error(instance:GetFullName() .. (" has invalid attribute '" .. (key .. ("' for '" .. (componentInfo.identifier .. "'")))))
				end
			else
				newAttributes[key] = attribute
			end
		end
		return newAttributes
	end
	function Components:getConfigValue(ctor, key)
		local _components = self.components
		local _ctor = ctor
		local metadata = _components[_ctor]
		if metadata then
			if metadata.config[key] ~= nil then
				return metadata.config[key]
			end
			local parentCtor = getmetatable(ctor)
			if parentCtor.__index ~= nil then
				return self:getConfigValue(parentCtor.__index, key)
			end
		end
	end
	function Components:safeCall(message, func)
		task.spawn(function()
			xpcall(func, function(err)
				local _err = err
				if type(_err) == "string" then
					local stack = debug.traceback(err, 2)
					warn(message)
					warn(stack)
				else
					warn(message)
					warn(err)
					warn(debug.traceback(nil, 2))
				end
			end)
		end)
	end
	function Components:setupComponent(instance, attributes, component, construct, _param)
		local config = _param.config
		local ctor = _param.ctor
		local identifier = _param.identifier
		component:setInstance(instance, attributes)
		construct()
		if Flamework._implements(component, "$:flamework@OnStart") then
			local name = instance:GetFullName()
			self:safeCall("Component '" .. (identifier .. ("' failed to start " .. name)), function()
				return component:onStart()
			end)
		end
		Modding.addListener(component)
		component.maid:GiveTask(function()
			return Modding.removeListener(component)
		end)
		if config.refreshAttributes == nil or config.refreshAttributes then
			local attributeCache = table.clone(attributes)
			local attributeGuards = self:getAttributeGuards(ctor)
			for attribute, guard in pairs(attributeGuards) do
				if type(attribute) == "string" then
					component.maid:GiveTask(instance:GetAttributeChangedSignal(attribute):Connect(function()
						local signal = component._attributeChangeHandlers[attribute]
						local value = instance:GetAttribute(attribute)
						local attributes = component.attributes
						if guard(value) then
							local _result = signal
							if _result ~= nil then
								_result:Fire(value, attributeCache[attribute])
							end
							attributes[attribute] = value
							attributeCache[attribute] = value
						end
					end))
				end
			end
		end
	end
	function Components:getComponentFromSpecifier(componentSpecifier)
		local _componentSpecifier = componentSpecifier
		local _result
		if type(_componentSpecifier) == "string" then
			local _idToObj = Reflect.idToObj
			local _componentSpecifier_1 = componentSpecifier
			_result = (_idToObj[_componentSpecifier_1])
		else
			_result = componentSpecifier
		end
		return _result
	end
	function Components:getIdFromSpecifier(componentSpecifier)
		if componentSpecifier ~= nil then
			local _componentSpecifier = componentSpecifier
			return if type(_componentSpecifier) == "string" then componentSpecifier else Reflect.getMetadata(componentSpecifier, "identifier")
		end
	end
	function Components:addIdMapping(value, id, inheritedComponents)
		local _inheritedComponents = inheritedComponents
		local _id = id
		local instances = _inheritedComponents[_id]
		if not instances then
			local _inheritedComponents_1 = inheritedComponents
			local _exp = id
			instances = {}
			local _instances = instances
			_inheritedComponents_1[_exp] = _instances
		end
		local _reverseComponentsMapping = self.reverseComponentsMapping
		local _id_1 = id
		local inheritedLookup = _reverseComponentsMapping[_id_1]
		if not inheritedLookup then
			local _reverseComponentsMapping_1 = self.reverseComponentsMapping
			local _exp = id
			inheritedLookup = {}
			local _inheritedLookup = inheritedLookup
			_reverseComponentsMapping_1[_exp] = _inheritedLookup
		end
		local _instances = instances
		local _value = value
		_instances[_value] = true
		local _inheritedLookup = inheritedLookup
		local _value_1 = value
		_inheritedLookup[_value_1] = true
	end
	function Components:removeIdMapping(instance, value, id)
		local _activeInheritedComponents = self.activeInheritedComponents
		local _instance = instance
		local inheritedComponents = _activeInheritedComponents[_instance]
		if not inheritedComponents then
			return nil
		end
		local _id = id
		local instances = inheritedComponents[_id]
		if not instances then
			return nil
		end
		local _reverseComponentsMapping = self.reverseComponentsMapping
		local _id_1 = id
		local inheritedLookup = _reverseComponentsMapping[_id_1]
		if not inheritedLookup then
			return nil
		end
		local _value = value
		instances[_value] = nil
		local _value_1 = value
		inheritedLookup[_value_1] = nil
		-- ▼ ReadonlySet.size ▼
		local _size = 0
		for _ in inheritedLookup do
			_size += 1
		end
		-- ▲ ReadonlySet.size ▲
		if _size == 0 then
			local _reverseComponentsMapping_1 = self.reverseComponentsMapping
			local _id_2 = id
			_reverseComponentsMapping_1[_id_2] = nil
		end
		-- ▼ ReadonlySet.size ▼
		local _size_1 = 0
		for _ in instances do
			_size_1 += 1
		end
		-- ▲ ReadonlySet.size ▲
		if _size_1 == 0 then
			local _id_2 = id
			inheritedComponents[_id_2] = nil
		end
		-- ▼ ReadonlyMap.size ▼
		local _size_2 = 0
		for _ in inheritedComponents do
			_size_2 += 1
		end
		-- ▲ ReadonlyMap.size ▲
		if _size_2 == 0 then
			local _activeInheritedComponents_1 = self.activeInheritedComponents
			local _instance_1 = instance
			_activeInheritedComponents_1[_instance_1] = nil
		end
	end
	function Components:getComponent(instance, componentSpecifier)
		local component = self:getComponentFromSpecifier(componentSpecifier)
		local _arg1 = "Could not find component from specifier: " .. tostring(componentSpecifier)
		assert(component, _arg1)
		local _activeComponents = self.activeComponents
		local _instance = instance
		local activeComponents = _activeComponents[_instance]
		if not activeComponents then
			return nil
		end
		return activeComponents[component]
	end
	function Components:getComponents(instance, componentSpecifier)
		local componentIdentifier = self:getIdFromSpecifier(componentSpecifier)
		if componentIdentifier == nil then
			return {}
		end
		local _activeInheritedComponents = self.activeInheritedComponents
		local _instance = instance
		local activeComponents = _activeInheritedComponents[_instance]
		if not activeComponents then
			return {}
		end
		local componentsSet = activeComponents[componentIdentifier]
		if not componentsSet then
			return {}
		end
		local _array = {}
		local _length = #_array
		for _v in componentsSet do
			_length += 1
			_array[_length] = _v
		end
		return _array
	end
	function Components:addComponent(instance, componentSpecifier, skipInstanceCheck)
		local component = self:getComponentFromSpecifier(componentSpecifier)
		local _arg1 = "Could not find component from specifier: " .. tostring(componentSpecifier)
		assert(component, _arg1)
		local componentInfo = self.components[component]
		assert(componentInfo, "Provided componentSpecifier does not exist")
		local attributeGuards = self:getAttributeGuards(component)
		local attributes = self:getAttributes(instance, componentInfo, attributeGuards)
		if skipInstanceCheck ~= true then
			local instanceGuard = self:getConfigValue(component, "instanceGuard")
			if instanceGuard ~= nil then
				local _arg0 = instanceGuard(instance)
				local _arg1_1 = instance:GetFullName() .. (" did not pass instance guard check for '" .. (componentInfo.identifier .. "'"))
				assert(_arg0, _arg1_1)
			end
		end
		local _activeComponents = self.activeComponents
		local _instance = instance
		local activeComponents = _activeComponents[_instance]
		if not activeComponents then
			local _activeComponents_1 = self.activeComponents
			local _exp = instance
			activeComponents = {}
			local _activeComponents_2 = activeComponents
			_activeComponents_1[_exp] = _activeComponents_2
		end
		local _activeInheritedComponents = self.activeInheritedComponents
		local _instance_1 = instance
		local inheritedComponents = _activeInheritedComponents[_instance_1]
		if not inheritedComponents then
			local _activeInheritedComponents_1 = self.activeInheritedComponents
			local _exp = instance
			inheritedComponents = {}
			local _inheritedComponents = inheritedComponents
			_activeInheritedComponents_1[_exp] = _inheritedComponents
		end
		local existingComponent = activeComponents[component]
		if existingComponent ~= nil then
			return existingComponent
		end
		local _binding = Modding.createDeferredDependency(component)
		local componentInstance = _binding[1]
		local construct = _binding[2]
		activeComponents[component] = componentInstance
		for _, parentClass in self:getOrderedParents(component) do
			local parentId = Reflect.getOwnMetadata(parentClass, "identifier")
			if parentId == nil then
				continue
			end
			self:addIdMapping(componentInstance, parentId, inheritedComponents)
		end
		local implementedList = Reflect.getMetadatas(component, "flamework:implements")
		for _, implemented in implementedList do
			for _1, id in implemented do
				self:addIdMapping(componentInstance, id, inheritedComponents)
			end
		end
		self:setupComponent(instance, attributes, componentInstance, construct, componentInfo)
		return componentInstance
	end
	function Components:removeComponent(instance, componentSpecifier)
		local component = self:getComponentFromSpecifier(componentSpecifier)
		local _arg1 = "Could not find component from specifier: " .. tostring(componentSpecifier)
		assert(component, _arg1)
		local _activeComponents = self.activeComponents
		local _instance = instance
		local activeComponents = _activeComponents[_instance]
		if not activeComponents then
			return nil
		end
		local existingComponent = activeComponents[component]
		if not existingComponent then
			return nil
		end
		existingComponent:destroy()
		activeComponents[component] = nil
		for _, parentClass in self:getOrderedParents(component) do
			local parentId = Reflect.getOwnMetadata(parentClass, "identifier")
			if parentId == nil then
				continue
			end
			self:removeIdMapping(instance, existingComponent, parentId)
		end
		local implementedList = Reflect.getMetadatas(component, "flamework:implements")
		for _, implemented in implementedList do
			for _1, id in implemented do
				self:removeIdMapping(instance, existingComponent, id)
			end
		end
		-- ▼ ReadonlyMap.size ▼
		local _size = 0
		for _ in activeComponents do
			_size += 1
		end
		-- ▲ ReadonlyMap.size ▲
		if _size == 0 then
			local _activeComponents_1 = self.activeComponents
			local _instance_1 = instance
			_activeComponents_1[_instance_1] = nil
		end
	end
	function Components:getAllComponents(componentSpecifier)
		local componentIdentifier = self:getIdFromSpecifier(componentSpecifier)
		if componentIdentifier == nil then
			return {}
		end
		local reverseMapping = self.reverseComponentsMapping[componentIdentifier]
		if not reverseMapping then
			return {}
		end
		local _array = {}
		local _length = #_array
		for _v in reverseMapping do
			_length += 1
			_array[_length] = _v
		end
		return _array
	end
end
-- (Flamework) Components metadata
Reflect.defineMetadata(Components, "identifier", "$c:init@Components")
Reflect.defineMetadata(Components, "flamework:implements", { "$:flamework@OnInit", "$:flamework@OnStart" })
Reflect.decorate(Components, "$:flamework@Service", Service, { {
	loadOrder = 0,
} })
Reflect.decorate(Components, "$:flamework@Controller", Controller, { {
	loadOrder = 0,
} })
return {
	Component = Component,
	BaseComponent = BaseComponent,
	Components = Components,
}
