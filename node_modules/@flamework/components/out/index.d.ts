/// <reference types="t" />
/// <reference types="@rbxts/types" />
/// <reference types="@rbxts/types" />
/// <reference types="maid" />
/// <reference types="signal" />
/// <reference types="@rbxts/compiler-types" />
/// <reference types="@rbxts/types" />
/// <reference types="@rbxts/types" />
import Maid from "@rbxts/maid";
import { t } from "@rbxts/t";
import { OnInit, OnStart } from "@flamework/core";
import Signal from "@rbxts/signal";
declare type Constructor<T = unknown> = new (...args: never[]) => T;
export interface ComponentConfig {
    tag?: string;
    attributes?: {
        [key: string]: t.check<unknown>;
    };
    defaults?: {
        [key: string]: unknown;
    };
    instanceGuard?: t.check<unknown>;
    predicate?: (instance: Instance) => boolean;
    refreshAttributes?: boolean;
}
/**
 * Register a class as a Component.
 *
 * @metadata flamework:implements flamework:parameters
 */
export declare const Component: ((opts?: ComponentConfig | undefined) => ((ctor: defined) => never) & {
    _flamework_Decorator: never;
}) & {
    _flamework_Parameters: [opts?: ComponentConfig | undefined];
};
export declare class BaseComponent<A = {}, I extends unknown = Instance> {
    /**
     * A maid that will be destroyed when the component is.
     */
    maid: Maid;
    /**
     * Attributes attached to this instance.
     */
    attributes: A;
    /**
     * The instance this component is attached to.
     * This should only be called in a component lifecycle event.
     */
    instance: I;
    setInstance(instance: I, attributes: unknown): void;
    setAttribute<T extends keyof A>(key: T, value: A[T], postfix?: boolean): A[T];
    /** @hidden */
    _attributeChangeHandlers: Map<string, Signal<(newValue: unknown, oldValue: unknown) => void, false>>;
    /**
     * Connect a callback to the change of a specific attribute.
     * @param name The name of the attribute
     * @param cb The callback
     */
    onAttributeChanged<K extends keyof A>(name: K, cb: (newValue: A[K], oldValue: A[K]) => void): RBXScriptConnection;
    /**
     * Destroys this component instance.
     */
    destroy(): void;
}
/**
 * This class is responsible for loading and managing
 * all components in the game.
 */
export declare class Components implements OnInit, OnStart {
    private components;
    private classParentCache;
    private activeComponents;
    private activeInheritedComponents;
    private reverseComponentsMapping;
    public onInit(): void;
    public onStart(): void;
    private getParentConstructor;
    private getOrderedParents;
    private getAttributeGuards;
    private getAttributes;
    private getConfigValue;
    private safeCall;
    private setupComponent;
    private getComponentFromSpecifier;
    private getIdFromSpecifier;
    private addIdMapping;
    private removeIdMapping;
    public getComponent<T>(instance: Instance): T | undefined;
    public getComponent<T>(instance: Instance, componentSpecifier: Constructor<T> | string): T | undefined;
    public getComponents<T>(instance: Instance): T[];
    public getComponents<T>(instance: Instance, componentSpecifier: Constructor<T> | string): T[];
    public addComponent<T, I extends unknown = Instance>(instance: I): T;
    public addComponent<T, I extends unknown = Instance>(instance: I, componentSpecifier: Constructor<T> | string): T;
    public removeComponent<T>(instance: Instance): void;
    public removeComponent<T>(instance: Instance, componentSpecifier: Constructor<BaseComponent> | string): void;
    public getAllComponents<T>(): T[];
    public getAllComponents<T>(componentSpecifier: Constructor<T> | string): T[];
}
export { };
