-- Compiled with roblox-ts v2.0.2
local TS = _G[script]
local _services = TS.import(script, TS.getModule(script, "@rbxts", "services"))
local Players = _services.Players
local RunService = _services.RunService
local Modding = TS.import(script, script.Parent, "modding").Modding
local Reflect = TS.import(script, script.Parent, "reflect").Reflect
local ArtificialDependency, Flamework
local Flamework = {}
do
	local _container = Flamework
	local flameworkConfig = {
		isDefault = true,
	}
	_container.flameworkConfig = flameworkConfig
	_container.isInitialized = false
	-- * @hidden
	local function resolveDependency(id)
		return Modding.resolveDependency(ArtificialDependency, id, 0, {})
	end
	_container.resolveDependency = resolveDependency
	-- * @hidden
	local function _addPaths(...)
		local args = { ... }
		local preloadPaths = {}
		for _, arg in args do
			local service = table.remove(arg, 1)
			local currentPath = game:GetService(service)
			if service == "StarterPlayer" then
				if arg[1] ~= "StarterPlayerScripts" then
					error("StarterPlayer only supports StarterPlayerScripts")
				end
				if not RunService:IsClient() then
					error("The server cannot load StarterPlayer content")
				end
				currentPath = Players.LocalPlayer:WaitForChild("PlayerScripts")
				table.remove(arg, 1)
			end
			do
				local i = 0
				local _shouldIncrement = false
				while true do
					if _shouldIncrement then
						i += 1
					else
						_shouldIncrement = true
					end
					if not (i < #arg) then
						break
					end
					currentPath = currentPath:WaitForChild(arg[i + 1])
				end
			end
			local _currentPath = currentPath
			table.insert(preloadPaths, _currentPath)
		end
		local preload = function(moduleScript)
			local start = os.clock()
			local success, value = pcall(require, moduleScript)
			local endTime = math.floor((os.clock() - start) * 1000)
			if not success then
				error(moduleScript:GetFullName() .. (" failed to preload (" .. (tostring(endTime) .. ("ms): " .. value))))
			end
		end
		for _, path in preloadPaths do
			if path:IsA("ModuleScript") then
				preload(path)
			end
			for _1, instance in path:GetDescendants() do
				if instance:IsA("ModuleScript") then
					preload(instance)
				end
			end
		end
	end
	_container._addPaths = _addPaths
	-- * @hidden
	local function _implements(object, id)
		local _exp = Reflect.getMetadatas(object, "flamework:implements")
		local _arg0 = function(impl)
			local _impl = impl
			local _id = id
			return table.find(_impl, _id) ~= nil
		end
		-- ▼ ReadonlyArray.some ▼
		local _result = false
		for _k, _v in _exp do
			if _arg0(_v, _k - 1, _exp) then
				_result = true
				break
			end
		end
		-- ▲ ReadonlyArray.some ▲
		return _result
	end
	_container._implements = _implements
	local function isService(ctor)
		return Modding.getDecorator(ctor, nil, "$:flamework@Service") ~= nil
	end
	local function isController(ctor)
		return Modding.getDecorator(ctor, nil, "$:flamework@Controller") ~= nil
	end
	local function isConstructor(obj)
		return obj.new ~= nil and obj.constructor ~= nil
	end
	local function getIdentifier(obj, suffix)
		if suffix == nil then
			suffix = ""
		end
		local _condition = Reflect.getMetadata(obj, "identifier")
		if _condition == nil then
			_condition = "UnidentifiedFlameworkListener" .. suffix
		end
		return _condition
	end
	local externalClasses = {}
	--[[
		*
		* Allow an external module to be bootstrapped by Flamework.ignite()
	]]
	local function registerExternalClass(ctor)
		local _ctor = ctor
		externalClasses[_ctor] = true
	end
	_container.registerExternalClass = registerExternalClass
	local hasFlameworkIgnited = false
	--[[
		*
		* Initialize Flamework.
		*
		* This will start up the lifecycle events on all currently registered
		* classes.
		*
		* You should preload all necessary directories before calling this
		* as newly registered classes will not run their lifecycle events.
		*
		* @returns All the dependencies that have been loaded.
	]]
	local function ignite(patchedConfig)
		if hasFlameworkIgnited then
			error("Flamework.ignite() should only be called once")
		end
		hasFlameworkIgnited = true
		if patchedConfig then
			for key, value in pairs(patchedConfig) do
				flameworkConfig[key] = value
			end
		end
		for ctor in Reflect.objToId do
			if RunService:IsServer() and not isService(ctor) then
				continue
			end
			if RunService:IsClient() and not isController(ctor) then
				continue
			end
			if not isConstructor(ctor) then
				continue
			end
			local isPatched = Reflect.getOwnMetadata(ctor, "flamework:isPatched")
			if flameworkConfig.loadOverride and (not (table.find(flameworkConfig.loadOverride, ctor) ~= nil) and not isPatched) then
				continue
			end
			local isExternal = Reflect.getOwnMetadata(ctor, "flamework:isExternal")
			if isExternal and not (externalClasses[ctor] ~= nil) then
				continue
			end
			Modding.resolveSingleton(ctor)
		end
		local dependencies = {}
		local decoratorType = if RunService:IsServer() then "$:flamework@Service" else "$:flamework@Controller"
		for ctor in Modding.getSingletons() do
			local decorator = Modding.getDecorator(ctor, nil, decoratorType)
			if not decorator then
				continue
			end
			local isExternal = Reflect.getOwnMetadata(ctor, "flamework:isExternal")
			if isExternal and not (externalClasses[ctor] ~= nil) then
				continue
			end
			local dependency = Modding.resolveSingleton(ctor)
			local _arg0 = { dependency, decorator.arguments[1] or {} }
			table.insert(dependencies, _arg0)
		end
		local start = {}
		local init = {}
		local tick = {}
		local render = {}
		local physics = {}
		local _arg0 = function(_param, _param_1)
			local a = _param[2]
			local b = _param_1[2]
			local _condition = a.loadOrder
			if _condition == nil then
				_condition = 1
			end
			local _condition_1 = b.loadOrder
			if _condition_1 == nil then
				_condition_1 = 1
			end
			return _condition < _condition_1
		end
		table.sort(dependencies, _arg0)
		Modding.onListenerAdded(function(object)
			local _object = object
			local _arg1 = getIdentifier(object, "/OnTick")
			tick[_object] = _arg1
			return tick
		end, "$:flamework@OnTick")
		Modding.onListenerAdded(function(object)
			local _object = object
			local _arg1 = getIdentifier(object, "/OnPhysics")
			physics[_object] = _arg1
			return physics
		end, "$:flamework@OnPhysics")
		Modding.onListenerAdded(function(object)
			local _object = object
			local _arg1 = getIdentifier(object, "/OnRender")
			render[_object] = _arg1
			return render
		end, "$:flamework@OnRender")
		Modding.onListenerRemoved(function(object)
			local _object = object
			-- ▼ Map.delete ▼
			local _valueExisted = tick[_object] ~= nil
			tick[_object] = nil
			-- ▲ Map.delete ▲
			return _valueExisted
		end, "$:flamework@OnTick")
		Modding.onListenerRemoved(function(object)
			local _object = object
			-- ▼ Map.delete ▼
			local _valueExisted = physics[_object] ~= nil
			physics[_object] = nil
			-- ▲ Map.delete ▲
			return _valueExisted
		end, "$:flamework@OnPhysics")
		Modding.onListenerRemoved(function(object)
			local _object = object
			-- ▼ Map.delete ▼
			local _valueExisted = render[_object] ~= nil
			render[_object] = nil
			-- ▲ Map.delete ▲
			return _valueExisted
		end, "$:flamework@OnRender")
		for _, _binding in dependencies do
			local dependency = _binding[1]
			if Flamework._implements(dependency, "$:flamework@OnInit") then
				local _arg0_1 = { dependency, getIdentifier(dependency) }
				table.insert(init, _arg0_1)
			end
			if Flamework._implements(dependency, "$:flamework@OnStart") then
				local _arg0_1 = { dependency, getIdentifier(dependency) }
				table.insert(start, _arg0_1)
			end
		end
		for _, _binding in init do
			local dependency = _binding[1]
			local identifier = _binding[2]
			debug.setmemorycategory(identifier)
			local initResult = dependency:onInit()
			if TS.Promise.is(initResult) then
				local status, value = initResult:awaitStatus()
				if status == TS.Promise.Status.Rejected then
					error("OnInit failed for dependency '" .. (identifier .. ("'. " .. tostring(value))))
				end
			end
			debug.resetmemorycategory()
		end
		_container.isInitialized = true
		RunService.Heartbeat:Connect(function(dt)
			for dependency, identifier in tick do
				task.spawn(function()
					debug.setmemorycategory(identifier)
					dependency:onTick(dt)
				end)
			end
		end)
		RunService.Stepped:Connect(function(time, dt)
			for dependency, identifier in physics do
				task.spawn(function()
					debug.setmemorycategory(identifier)
					dependency:onPhysics(dt, time)
				end)
			end
		end)
		if RunService:IsClient() then
			RunService.RenderStepped:Connect(function(dt)
				for dependency, identifier in render do
					task.spawn(function()
						debug.setmemorycategory(identifier)
						dependency:onRender(dt)
					end)
				end
			end)
		end
		for _, _binding in start do
			local dependency = _binding[1]
			local indentifier = _binding[2]
			task.spawn(function()
				debug.setmemorycategory(indentifier)
				dependency:onStart()
			end)
		end
		return dependencies
	end
	_container.ignite = ignite
	--[[
		*
		* Preload the specified paths by requiring all ModuleScript descendants.
	]]
	--[[
		*
		* Retrieve the identifier for the specified type.
	]]
	--[[
		*
		* Check if the constructor implements the specified interface.
	]]
	--[[
		*
		* Check if object implements the specified interface.
	]]
	--[[
		*
		* Creates a type guard from any arbitrary type.
	]]
	--[[
		*
		* Hash a function using the method used internally by Flamework.
		* If a context is provided, then Flamework will create a new hash
		* if the specified string does not have one in that context.
		* @param str The string to hash
		* @param context A scope for the hash
	]]
	--[[
		*
		* Utility for use in test suites, not recommended for anything else.
	]]
	local Testing = {}
	do
		local _container_1 = Testing
		local function patchDependency(patchedClass, id)
			if id == nil then
				error("Patching failed, no ID")
			end
			local _idToObj = Reflect.idToObj
			local _id = id
			local idCtor = _idToObj[_id]
			if idCtor == nil then
				error("Dependency " .. (id .. " was not found and cannot be patched."))
			end
			if Modding.getSingletons()[idCtor] ~= nil then
				error(id .. " has already been resolved, continuing is unsafe")
			end
			local objMetadata = Reflect.metadata[idCtor]
			if not objMetadata then
				error("Dependency " .. (id .. " has no existing metadata."))
			end
			Reflect.defineMetadata(idCtor, "flamework:isPatched", true)
			Reflect.metadata[idCtor] = nil
			local _metadata = Reflect.metadata
			local _patchedClass = patchedClass
			_metadata[_patchedClass] = objMetadata
			local _objToId = Reflect.objToId
			local _patchedClass_1 = patchedClass
			local _id_1 = id
			_objToId[_patchedClass_1] = _id_1
			local _idToObj_1 = Reflect.idToObj
			local _id_2 = id
			local _patchedClass_2 = patchedClass
			_idToObj_1[_id_2] = _patchedClass_2
		end
		_container_1.patchDependency = patchDependency
	end
	_container.Testing = Testing
end
--[[
	*
	* An internal class used for resolving the Dependency<T> macro.
]]
do
	ArtificialDependency = setmetatable({}, {
		__tostring = function()
			return "ArtificialDependency"
		end,
	})
	ArtificialDependency.__index = ArtificialDependency
	function ArtificialDependency.new(...)
		local self = setmetatable({}, ArtificialDependency)
		return self:constructor(...) or self
	end
	function ArtificialDependency:constructor()
	end
end
Reflect.defineMetadata(ArtificialDependency, "identifier", "$:flamework@ArtificialDependency")
Reflect.defineMetadata(ArtificialDependency, "flamework:isArtificial", true)
--[[
	*
	* Register a class as a Service.
	*
	* @server
	* @metadata flamework:implements flamework:parameters
]]
local Service = Modding.createMetaDecorator("Class")
--[[
	*
	* Register a class as a Controller.
	*
	* @client
	* @metadata flamework:implements flamework:parameters
]]
local Controller = Modding.createMetaDecorator("Class")
--[[
	*
	* Marks this class as an external class.
	*
	* External classes are designed for packages and won't be
	* bootstrapped unless explicitly specified. Excluding this
	* inside of a package will make the class load as long as
	* it has been loaded.
]]
local External = Modding.createDecorator("Class", function(descriptor)
	Reflect.defineMetadata(descriptor.object, "flamework:isExternal", true)
end)
--[[
	*
	* Hook into the OnInit lifecycle event.
]]
--[[
	*
	* Hook into the OnStart lifecycle event.
]]
--[[
	*
	* Hook into the OnTick lifecycle event.
	* Equivalent to: RunService.Heartbeat
]]
--[[
	*
	* Hook into the OnPhysics lifecycle event.
	* Equivalent to: RunService.Stepped
]]
--[[
	*
	* Hook into the OnRender lifecycle event.
	* Equivalent to: RunService.RenderStepped
	*
	* @client
]]
return {
	Flamework = Flamework,
	Service = Service,
	Controller = Controller,
	External = External,
}
