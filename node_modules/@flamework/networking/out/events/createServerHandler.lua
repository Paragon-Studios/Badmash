-- Compiled with roblox-ts v2.0.2
local TS = _G[script]
local Players = TS.import(script, TS.getModule(script, "@rbxts", "services")).Players
local fireNetworkHandler = TS.import(script, script.Parent.Parent, "handlers").fireNetworkHandler
local createMiddlewareProcessor = TS.import(script, script.Parent.Parent, "middleware", "createMiddlewareProcessor").createMiddlewareProcessor
local createServerMethod
local function createServerHandler(remotes, networkInfos, serverEvents, clientEvents, middlewareFactoryList)
	local handler = {}
	local bindables = {}
	local processors = {}
	for name in pairs(serverEvents) do
		local bindable = Instance.new("BindableEvent")
		bindables[name] = bindable
	end
	for name, remote in remotes do
		local networkInfo = networkInfos[name]
		local _result = middlewareFactoryList
		if _result ~= nil then
			_result = _result[name]
		end
		local middlewareProcessor = createMiddlewareProcessor(_result, networkInfo, function(player, ...)
			local args = { ... }
			local _result_1 = bindables[name]
			if _result_1 ~= nil then
				_result_1 = _result_1:Fire(player, unpack(args))
			end
			return _result_1
		end)
		processors[name] = middlewareProcessor
		remote.OnServerEvent:Connect(function(player, ...)
			local args = { ... }
			local guards = serverEvents[name]
			if not guards then
				return nil
			end
			do
				local i = 0
				local _shouldIncrement = false
				while true do
					if _shouldIncrement then
						i += 1
					else
						_shouldIncrement = true
					end
					if not (i < #guards) then
						break
					end
					local guard = guards[i + 1]
					if not guard(args[i + 1]) then
						fireNetworkHandler("onBadRequest", player, networkInfo, i)
						return nil
					end
				end
			end
			middlewareProcessor(player, unpack(args))
		end)
	end
	for name, remote in remotes do
		local _result = serverEvents[name]
		if _result ~= nil then
			_result = #_result
		end
		local _condition = _result
		if _condition == nil then
			_condition = 0
		end
		handler[name] = createServerMethod(remote, _condition, bindables[name], processors[name])
	end
	return handler
end
function createServerMethod(remote, paramCount, bindable, process)
	local method = {
		fire = function(self, players, ...)
			local args = { ... }
			local _players = players
			if typeof(_players) == "Instance" then
				remote:FireClient(players, unpack(args))
			else
				for _, player in players do
					remote:FireClient(player, unpack(args))
				end
			end
		end,
		broadcast = function(self, ...)
			local args = { ... }
			remote:FireAllClients(unpack(args))
		end,
		except = function(self, players, ...)
			local args = { ... }
			local _players = players
			if typeof(_players) == "Instance" then
				players = { players }
			end
			for _, player in Players:GetPlayers() do
				if not (table.find(players, player) ~= nil) then
					self:fire(player, unpack(args))
				end
			end
		end,
		connect = function(self, callback, customGuards)
			local _bindable = bindable
			local _arg1 = "Event " .. (remote.Name .. " is not registered as a receiver.")
			assert(_bindable, _arg1)
			return bindable.Event:Connect(function(player, ...)
				local args = { ... }
				if customGuards then
					do
						local i = 0
						local _shouldIncrement = false
						while true do
							if _shouldIncrement then
								i += 1
							else
								_shouldIncrement = true
							end
							if not (i < paramCount) then
								break
							end
							local guard = customGuards[i + 1]
							if guard ~= nil and not guard(args[i + 1]) then
								return nil
							end
						end
					end
				end
				return callback(player, unpack(args))
			end)
		end,
		predict = function(self, player, ...)
			local args = { ... }
			local _process = process
			local _arg1 = "Event " .. (remote.Name .. " does not have a middleware processor.")
			assert(_process, _arg1)
			process(player, unpack(args))
		end,
	}
	setmetatable(method, {
		__call = function(method, player, ...)
			local args = { ... }
			method:fire(player, unpack(args))
		end,
	})
	return method
end
return {
	createServerHandler = createServerHandler,
}
