-- Compiled with roblox-ts v2.1.0
local TS = _G[script]
local Spring = TS.import(script, TS.getModule(script, "@rbxts", "flipper").src).Spring
local _flipper = TS.import(script, script.Parent, "flipper")
local getBinding = _flipper.getBinding
local useMotor = _flipper.useMotor
local _object = {}
local _left = "number"
local _arg0 = function(value, ctor, options)
	if options == nil then
		options = {}
	end
	local motor = useMotor(value)
	motor:setGoal(ctor.new(value, options))
	return getBinding(motor)
end
_object[_left] = _arg0
local _left_1 = "Color3"
local _arg0_1 = function(color, ctor, options)
	if options == nil then
		options = {}
	end
	local motor = useMotor({ color.R, color.G, color.B })
	motor:setGoal({ ctor.new(color.R, options), ctor.new(color.G, options), ctor.new(color.B, options) })
	return getBinding(motor):map(function(_param)
		local r = _param[1]
		local g = _param[2]
		local b = _param[3]
		return Color3.new(r, g, b)
	end)
end
_object[_left_1] = _arg0_1
local _left_2 = "UDim"
local _arg0_2 = function(udim, ctor, options)
	local motor = useMotor({ udim.Scale, udim.Offset })
	motor:setGoal({ ctor.new(udim.Scale, options), ctor.new(udim.Offset, options) })
	return getBinding(motor):map(function(_param)
		local s = _param[1]
		local o = _param[2]
		return UDim.new(s, o)
	end)
end
_object[_left_2] = _arg0_2
local _left_3 = "UDim2"
local _arg0_3 = function(udim2, ctor, options)
	local motor = useMotor({ udim2.X.Scale, udim2.X.Offset, udim2.Y.Scale, udim2.Y.Offset })
	motor:setGoal({ ctor.new(udim2.X.Scale, options), ctor.new(udim2.X.Offset, options), ctor.new(udim2.Y.Scale, options), ctor.new(udim2.Y.Offset, options) })
	return getBinding(motor):map(function(_param)
		local xS = _param[1]
		local xO = _param[2]
		local yS = _param[3]
		local yO = _param[4]
		return UDim2.new(xS, math.round(xO), yS, math.round(yO))
	end)
end
_object[_left_3] = _arg0_3
local _left_4 = "Vector2"
local _arg0_4 = function(vector2, ctor, options)
	local motor = useMotor({ vector2.X, vector2.Y })
	motor:setGoal({ ctor.new(vector2.X, options), ctor.new(vector2.Y, options) })
	return getBinding(motor):map(function(_param)
		local X = _param[1]
		local Y = _param[2]
		return Vector2.new(X, Y)
	end)
end
_object[_left_4] = _arg0_4
local _left_5 = "table"
local _arg0_5 = function(array, ctor, options)
	local motor = useMotor(array)
	local _fn = motor
	local _array = array
	local _arg0_6 = function(value)
		return ctor.new(value, options)
	end
	-- ▼ ReadonlyArray.map ▼
	local _newValue = table.create(#_array)
	for _k, _v in _array do
		_newValue[_k] = _arg0_6(_v, _k - 1, _array)
	end
	-- ▲ ReadonlyArray.map ▲
	_fn:setGoal(_newValue)
	return getBinding(motor)
end
_object[_left_5] = _arg0_5
local motorHooks = _object
local function useAnimation(value, ctor, options)
	local _exp = motorHooks
	local _value = value
	local hook = _exp[typeof(_value)]
	local _value_1 = value
	local _arg1 = "useAnimation: Value of type " .. (typeof(_value_1) .. " is not supported")
	assert(hook, _arg1)
	return hook(value, (ctor or Spring), options)
end
return {
	useAnimation = useAnimation,
}
