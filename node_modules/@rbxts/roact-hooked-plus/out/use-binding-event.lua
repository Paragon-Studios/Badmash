-- Compiled with roblox-ts v2.1.0
local TS = _G[script]
local _roact_hooked = TS.import(script, TS.getModule(script, "@rbxts", "roact-hooked").src)
local useEffect = _roact_hooked.useEffect
local useMutable = _roact_hooked.useMutable
local useState = _roact_hooked.useState
local _binding_utils = TS.import(script, script.Parent, "utils", "binding-utils")
local getBindingValue = _binding_utils.getBindingValue
local isBinding = _binding_utils.isBinding
local function getInternalApi(binding)
	for k, v in pairs(binding) do
		if tostring(k) == "Symbol(BindingImpl)" then
			return v
		end
	end
end
--[[
	*
	* Subscribes to a binding and calls the callback when the value changes.
	* If the value is not a binding, this behaves like useEffect.
	* @param binding The binding or value to subscribe to.
	* @param callback The callback to call when the value changes.
]]
local function useBindingEvent(binding, callback)
	local callbackRef = useMutable(callback)
	callbackRef.current = callback
	useEffect(function()
		if not isBinding(binding) then
			callbackRef.current(binding)
			return nil
		end
		callbackRef.current(binding:getValue())
		local _result = getInternalApi(binding)
		if _result ~= nil then
			_result = _result.subscribe(function(newValue)
				callbackRef.current(newValue)
			end)
		end
		return _result
	end, { binding })
end
--[[
	*
	* Returns the state of the binding wrapped in a `useState` hook. When the
	* value changes, the component will re-render.
	* @param binding The binding or value to get the state of.
	* @returns The value of the binding.
]]
local function useBindingState(binding)
	local value, setValue = useState(getBindingValue(binding))
	useBindingEvent(binding, setValue)
	return value
end
return {
	useBindingEvent = useBindingEvent,
	useBindingState = useBindingState,
}
