-- Compiled with roblox-ts v2.1.0
local TS = _G[script]
local _roact_hooked = TS.import(script, TS.getModule(script, "@rbxts", "roact-hooked").src)
local useCallback = _roact_hooked.useCallback
local useEffect = _roact_hooked.useEffect
local useMutable = _roact_hooked.useMutable
local useState = _roact_hooked.useState
local UserInputService = TS.import(script, TS.getModule(script, "@rbxts", "services")).UserInputService
local _set_timeout = TS.import(script, script.Parent, "utils", "set-timeout")
local clearTimeout = _set_timeout.clearTimeout
local setTimeout = _set_timeout.setTimeout
local DEFAULT_INPUTS = { Enum.UserInputType.Keyboard, Enum.UserInputType.Touch, Enum.UserInputType.Gamepad1, Enum.UserInputType.MouseButton1, Enum.UserInputType.MouseButton2, Enum.UserInputType.MouseButton3 }
local DEFAULT_OPTIONS = {
	inputs = DEFAULT_INPUTS,
	useWindowFocus = true,
	initialState = true,
}
local function useIdle(timeout, options)
	local _object = {}
	for _k, _v in DEFAULT_OPTIONS do
		_object[_k] = _v
	end
	if type(options) == "table" then
		for _k, _v in options do
			_object[_k] = _v
		end
	end
	local _binding = _object
	local inputs = _binding.inputs
	local useWindowFocus = _binding.useWindowFocus
	local initialState = _binding.initialState
	local idle, setIdle = useState(initialState)
	local timer = useMutable()
	local handleInput = useCallback(function()
		setIdle(false)
		if timer.current then
			clearTimeout(timer.current)
		end
		timer.current = setTimeout(function()
			setIdle(true)
		end, timeout)
	end, { timeout })
	useEffect(function()
		local events = UserInputService.InputBegan:Connect(function(input)
			local _userInputType = input.UserInputType
			if table.find(inputs, _userInputType) ~= nil then
				handleInput()
			end
		end)
		return function()
			events:Disconnect()
		end
	end, { handleInput })
	useEffect(function()
		if not useWindowFocus then
			return nil
		end
		local windowFocused = UserInputService.WindowFocused:Connect(handleInput)
		local windowFocusReleased = UserInputService.WindowFocusReleased:Connect(function()
			if timer.current then
				clearTimeout(timer.current)
				timer.current = nil
			end
			setIdle(true)
		end)
		return function()
			windowFocused:Disconnect()
			windowFocusReleased:Disconnect()
		end
	end, { useWindowFocus, handleInput })
	return idle
end
return {
	useIdle = useIdle,
}
