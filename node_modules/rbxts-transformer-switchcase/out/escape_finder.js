"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.recursiveStatementHasEscape = exports.statementHasOrIsEscape = void 0;
var ts = __importStar(require("typescript"));
var path_checker_1 = require("./path_checker");
/**
 * Checks if a statement is an escape, if not it will recurse into it using recurseStatementHasEscape.
 * @returns true if the statement has or is an escape
 */
function statementHasOrIsEscape(context, statement) {
    if (ts.isBreakStatement(statement)
        || ts.isReturnStatement(statement)
        || ts.isContinueStatement(statement))
        return true;
    return recursiveStatementHasEscape(context, statement, {
        // initial accepted breaks
        break: true,
        continue: true,
        return: true
    });
}
exports.statementHasOrIsEscape = statementHasOrIsEscape;
/**
 * Checks if a statement is an escape, if not it will recurse into it.
 * It also keeps track of which escapes can still be used to escape the upper switch statement.
 * @returns true if the statement has or is an escape
 */
function recursiveStatementHasEscape(context, nodeToRecurse, accepted) {
    var foundBreak = false;
    for (var _i = 0, _a = nodeToRecurse.getChildren(); _i < _a.length; _i++) {
        var node = _a[_i];
        if ((accepted.break && ts.isBreakStatement(node))
            || (accepted.continue && ts.isContinueStatement(node))
            || (accepted.return && ts.isReturnStatement(node))) {
            foundBreak = true;
            break;
        }
        // clone so we can edit it (each node gets its own version based on its parent node)
        var localAccepted = ts.clone(accepted);
        // stop accepting certain escapes when inside certain types of nodes
        if (ts.isFunctionLikeDeclaration(node)) {
            localAccepted.return = false;
            // breaks and continues inside a function don't work for the current switch
            localAccepted.break = false;
            localAccepted.continue = false;
        }
        else if (ts.isForStatement(node) || ts.isForInOrOfStatement(node)) {
            localAccepted.break = false;
            localAccepted.continue = false;
        }
        else if (ts.isSwitchStatement(node)) {
            localAccepted.break = false;
        }
        else if (ts.isIfStatement(node)) {
        }
        // can't accept any escapes anymore, so don't go deeper
        if (!(localAccepted.break || localAccepted.continue || localAccepted.return))
            break;
        // go deeper
        foundBreak =
            ts.isSwitchStatement(node) ? (0, path_checker_1.switchEscapes)(context, node, localAccepted) // if switch then switchEscapes()
                : ts.isIfStatement(node) ? (0, path_checker_1.ifEscapes)(context, node, localAccepted) // else if if then ifEscapes()
                    : recursiveStatementHasEscape(context, node, accepted); // else recurse
        if (foundBreak != undefined)
            break;
    }
    return foundBreak;
}
exports.recursiveStatementHasEscape = recursiveStatementHasEscape;
exports.default = statementHasOrIsEscape;
